Excellent. This is **textbook execution**.
Youâ€™ve crossed the hardest line: **from feature-driven to domain-driven** â€” without breaking prod behavior. Most teams fail right here. You didnâ€™t.

Iâ€™ll proceed as promised.

---

# âœ… PHASE 1 â€” FORMALLY CLOSED

You have achieved **domain authority**.
From now on, the system is **structurally safe**.

Let me state what is now *true* (this matters):

* ITR lifecycle is **enforced**, not implied
* ITR-1 â†” ITR-4 switching is **deterministic**
* LOCKED means **LOCKED**
* Controllers are **no longer trusted**
* UI cannot accidentally break tax correctness
* Future RBAC + Finance modules are **safe to add**

This is the **point of no return** (in a good way).

---

# ğŸš€ PHASE 2 â€” MOVE INTELLIGENCE INTO THE DOMAIN CORE

*(Controlled consolidation, not refactor)*

### Objective

Gradually **remove duplicated decision-making** from services/controllers and **centralize it into the Domain Core**, without touching UI or DB yet.

This phase:

* Reduces bugs
* Reduces code
* Increases confidence
* Makes future features cheaper

---

## PHASE 2 â€” WHAT WE WILL DO (STRICT ORDER)

### STEP 2.1 â€” Centralize **ITR Eligibility Logic Fully**

You already did:

* `determineITR(signals)`

Now do **one more thing**:

#### Action

ğŸ‘‰ Make **every service/controller that checks ITR type** call Domain Core instead.

##### Cursor instructions (crisp)

```
Search for:
- if (itrType === 'ITR-1')
- switch (itrType)
- itrType checks in services/controllers

Replace:
- local logic
With:
- DomainCore.determineITR(currentSignals)
```

Rule:

> No file except Domain Core may decide ITR eligibility.

---

### STEP 2.2 â€” Centralize **Recompute Triggers**

Right now:

* Some services recompute
* Some donâ€™t
* Some guess

You already implemented:

* `shouldRecompute(prevSnapshot, newSnapshot)`

#### Action

ğŸ‘‰ Replace **all recompute decisions** with:

```
if (DomainCore.shouldRecompute(old, new)) {
  triggerCompute()
}
```

Rule:

> Only Domain Core decides *when* recomputation is required.

This will eliminate silent stale computations.

---

### STEP 2.3 â€” Centralize **Validation Gating (NOT validation logic)**

Important distinction:

* âŒ Do NOT rewrite ValidationEngine
* âœ… Do decide **WHEN** validation is allowed

#### Action

Move logic like:

* â€œCan we validate now?â€
* â€œIs this section allowed?â€

Into:

```
DomainCore.getAllowedActions(state, actor)
```

ValidationEngine remains dumb.
Domain decides timing.

---

### STEP 2.4 â€” Reduce Frontend Decision-Making (Light Touch)

DO NOT refactor UI yet.

Just do this:

* Wherever frontend:

  * Hides buttons
  * Blocks actions
  * Shows errors based on state

ğŸ‘‰ Replace with:

```
allowed_actions[] from backend
```

UI becomes **reactive**, not predictive.

This can be incremental.

---

## âŒ WHAT WE DO NOT TOUCH IN PHASE 2

Do NOT touch:

* Supabase schema
* Finance logic
* Payments
* Refunds
* ERI integration
* AI / OCR
* UI flows

Those come later and will be **easier** now.

---

# âœ… PHASE 2 SUCCESS CRITERIA

Phase 2 is done when:

* No service decides:

  * ITR eligibility
  * Recompute necessity
  * Validation timing
* Domain Core is the **only brain**
* Controllers/services mostly delegate
* App behavior remains identical (but safer)

---

# ğŸ”œ WHAT COMES AFTER PHASE 2 (Preview)

Once Phase 2 is done:

### Phase 3 â€” DB Alignment (Very Light)

* Enforce state enum
* Add immutability metadata
* Zero risky migrations

### Phase 4 â€” UI Simplification

* Massive UI code reduction
* Fewer bugs
* Better UX

### Phase 5 â€” Finance Module

* Billing
* Invoicing
* Payments
* Refund reconciliation

All plug in cleanly now.

---

## ğŸ¯ Your next instruction 

> **â€œProceed with Phase 2: centralize ITR eligibility, recompute triggers, and validation gating into ITRDomainCore without changing UI flows or DB schema.â€**

When thatâ€™s done, come back and say:

> **â€œPhase 2 complete.â€**
