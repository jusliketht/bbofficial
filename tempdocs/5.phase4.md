Excellent. **Phase 3 is cleanly done** â€” and done the *right* way.

Iâ€™ll be crisp and decisive now.

---

# âœ… PHASE 3 â€” FORMALLY CLOSED

What is now **true** (this matters):

* `lifecycle_state` is canonical and durable
* LOCK / FILE moments are persisted correctly
* ITR type freezing is DB-safe
* Computation traceability exists
* No triggers, no business logic in SQL
* Backward compatibility preserved

This is **platform-grade DB hardening**. Well executed.

You are now ready for **Phase 4 without risk**.

---

# ğŸš€ PHASE 4 â€” UI SIMPLIFICATION (EXECUTION MODE)

You already have:

* `allowedActions`
* `lifecycleState`
* Domain Guard enforcing legality

Now UI must **submit to the domain**.

Below is the **final, executable Phase 4 plan** (tightened based on your current state).

---

## ğŸ”¹ STEP 4.1 â€” Declare UI Contract (DO THIS FIRST)

Create (or finalize) a single contract type:

```ts
type FilingUIContext = {
  lifecycleState: DomainState
  itrType: ITRType
  allowedActions: DomainAction[]
}
```

**Rule**

> Every page/component must consume this â€” no exceptions.

---

## ğŸ”¹ STEP 4.2 â€” Kill Step/Wizard Logic (MANDATORY)

Search frontend for:

* `currentStep`
* `stepIndex`
* `stepOrder`
* `nextStep`
* `previousStep`

**Action**

* Remove step progression assumptions
* Replace with:

```ts
allowedActions.includes('ACTION_NAME')
```

Example:

```ts
// âŒ old
if (step >= 3 && itrType === 'ITR-2')

// âœ… new
if (allowedActions.includes('EDIT_CAPITAL_GAINS'))
```

---

## ğŸ”¹ STEP 4.3 â€” Make Pages State-AWARE (NOT FLOW-AWARE)

Each major page should declare:

```ts
const supportedStates = ['DATA_COLLECTED','DATA_CONFIRMED','COMPUTED']
```

At runtime:

* If current state not supported â†’ render read-only or redirect
* No routing gymnastics
* No step guards

This aligns UI directly to the **state machine**.

---

## ğŸ”¹ STEP 4.4 â€” Centralize UI Gating (ONE HOOK)

Confirm you have (or create):

```ts
useFilingContext(filingId)
```

This hook:

* Calls `/allowed-actions`
* Returns `FilingUIContext`

**Rule**

> UI must never infer legality locally.

All buttons / edits / submits must check:

```ts
allowedActions.includes('ACTION')
```

---

## ğŸ”¹ STEP 4.5 â€” Read-Only Becomes Automatic

With Domain + DB + allowedActions:

When:

```
lifecycleState >= LOCKED
```

UI should:

* Become fully read-only
* No extra flags
* No per-field hacks

If this is not happening â†’ UI still has illegal logic.

---

## ğŸ”¹ STEP 4.6 â€” Error Messaging (FINAL TOUCH)

Replace:

* â€œInvalid actionâ€
* â€œSomething went wrongâ€

With:

* Domain-provided reason codes
* Simple, calm copy:

  > â€œThis return is locked for filing.â€

This builds **trust**.

---

## âŒ DO NOT DO IN PHASE 4 (RECONFIRM)

Do NOT:

* Redesign UI
* Change navigation
* Add animations
* Touch branding
* Optimize performance
* Touch finance

This is **logic simplification only**.

---

## âœ… PHASE 4 SUCCESS CHECKLIST

Phase 4 is complete when:

* No step-based logic remains
* UI never decides â€œwhat is allowedâ€
* All actions depend on `allowedActions`
* LOCKED state auto-enforces read-only UI
* Adding a new domain state does NOT break UI

---

## ğŸ“Œ CURSOR INSTRUCTION (FINAL)

Give Cursor **exactly this**:

> **â€œProceed with Phase 4 UI simplification: remove all step/wizard logic, make UI state-aware (not flow-aware), gate all actions using allowedActions via a single hook, and enforce read-only UI automatically for LOCKED and later states. Do not redesign UI or change navigation.â€**

---

## ğŸ”œ WHAT COMES NEXT (NO RUSH)

Once Phase 4 is done, you unlock:

### ğŸ’° Phase 5 â€” Finance Module

* Billing
* Invoicing
* Service fees
* Tax payments
* Refund reconciliation

It will plug in **cleanly** because of what youâ€™ve already done.

When Cursor finishes Phase 4, come back with:

> **â€œPhase 4 complete.â€**

Youâ€™re building this like a **real fintech platform**, not a tax form app.
