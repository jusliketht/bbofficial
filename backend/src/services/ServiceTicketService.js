// =====================================================
// SERVICE TICKET SERVICE (BUSINESS LOGIC)
// =====================================================

const { ServiceTicket, ServiceTicketMessage } = require('../models');
const auditService = require('./AuditService');
const enterpriseLogger = require('../utils/logger');
const { AppError } = require('../middleware/errorHandler');
const featureFlags = require('../common/featureFlags');
const sseNotificationService = require('./SSENotificationService');

class ServiceTicketService {
  constructor() {
    this.defaultSlaHours = 24;
    this.autoAssignmentEnabled = featureFlags.isEnabled('feature_service_ticket_auto_assignment');
    
    enterpriseLogger.info('ServiceTicketService initialized');
  }

  /**
   * Create a new service ticket
   * @param {object} ticketData - Ticket data
   * @param {string} createdBy - User creating the ticket
   * @param {string} ipAddress - IP address
   * @returns {Promise<object>} - Created ticket
   */
  async createTicket(ticketData, createdBy, ipAddress = null) {
    try {
      const {
        userId,
        filingId,
        memberId,
        ticketType,
        priority,
        subject,
        description,
        tags = [],
        attachments = []
      } = ticketData;

      // Validate required fields
      this.validateTicketData(ticketData);

      // Auto-assign if enabled
      let assignedTo = null;
      if (this.autoAssignmentEnabled) {
        assignedTo = await this.autoAssignTicket(ticketType, priority);
      }

      // Create the ticket
      const ticket = await ServiceTicket.create({
        userId,
        filingId,
        memberId,
        assignedTo,
        ticketType,
        priority: priority || 'MEDIUM',
        subject,
        description,
        slaHours: this.getSlaHoursForType(ticketType),
        tags,
        attachments,
        metadata: {
          createdBy,
          ipAddress,
          createdAt: new Date().toISOString()
        }
      });

      // Create initial message
      await ServiceTicketMessage.create({
        ticketId: ticket.id,
        senderId: createdBy,
        senderType: 'USER',
        message: description,
        messageType: 'TEXT'
      });

      // Log audit event
      await auditService.logDataAccess(
        createdBy,
        'create',
        'service_ticket',
        ticket.id,
        {
          ticketNumber: ticket.ticketNumber,
          ticketType,
          priority: ticket.priority,
          subject,
          filingId,
          memberId
        },
        ipAddress
      );

      enterpriseLogger.info('Service ticket created', {
        ticketId: ticket.id,
        ticketNumber: ticket.ticketNumber,
        userId,
        ticketType,
        priority: ticket.priority,
        assignedTo
      });

      // Send SSE notification for ticket creation
      sseNotificationService.sendTicketUpdate(userId, {
        id: ticket.id,
        ticketNumber: ticket.ticketNumber,
        oldStatus: null,
        newStatus: 'OPEN',
        ticketType: ticket.ticketType,
        priority: ticket.priority,
        subject: ticket.subject
      });

      return {
        success: true,
        ticket: {
          id: ticket.id,
          ticketNumber: ticket.ticketNumber,
          ticketType: ticket.ticketType,
          priority: ticket.priority,
          status: ticket.status,
          subject: ticket.subject,
          description: ticket.description,
          assignedTo: ticket.assignedTo,
          slaHours: ticket.slaHours,
          createdAt: ticket.createdAt,
          tags: ticket.tags,
          attachments: ticket.attachments
        }
      };

    } catch (error) {
      enterpriseLogger.error('Failed to create service ticket', {
        error: error.message,
        ticketData
      });
      throw error;
    }
  }

  /**
   * Auto-create ticket for filing
   * @param {object} filingData - Filing data
   * @returns {Promise<object>} - Created ticket
   */
  async autoCreateFilingTicket(filingData) {
    try {
      const {
        id: filingId,
        userId,
        itrType,
        memberId
      } = filingData;

      const ticketData = {
        userId,
        filingId,
        memberId,
        ticketType: 'FILING_SUPPORT',
        priority: 'MEDIUM',
        subject: `ITR Filing Support - ${itrType}`,
        description: `User needs assistance with ${itrType} filing. Filing ID: ${filingId}`,
        tags: ['auto-generated', 'filing-support', itrType.toLowerCase()],
        attachments: []
      };

      const result = await this.createTicket(ticketData, userId);
      
      // Mark as auto-generated
      await ServiceTicket.update(
        { 
          autoGenerated: true,
          generationReason: 'FILING_CREATED'
        },
        { where: { id: result.ticket.id } }
      );

      enterpriseLogger.info('Auto-generated filing ticket created', {
        ticketId: result.ticket.id,
        ticketNumber: result.ticket.ticketNumber,
        filingId,
        itrType
      });

      return result;

    } catch (error) {
      enterpriseLogger.error('Failed to auto-create filing ticket', {
        error: error.message,
        filingData
      });
      throw error;
    }
  }

  /**
   * Get user tickets
   * @param {string} userId - User ID
   * @param {object} filters - Filter options
   * @returns {Promise<Array>} - Ticket list
   */
  async getUserTickets(userId, filters = {}) {
    try {
      const whereClause = {
        userId,
        isDeleted: false
      };

      // Apply filters
      if (filters.status) {
        whereClause.status = filters.status;
      }
      if (filters.ticketType) {
        whereClause.ticketType = filters.ticketType;
      }
      if (filters.priority) {
        whereClause.priority = filters.priority;
      }
      if (filters.filingId) {
        whereClause.filingId = filters.filingId;
      }

      const tickets = await ServiceTicket.findAll({
        where: whereClause,
        order: [['createdAt', 'DESC']],
        limit: filters.limit || 50,
        offset: filters.offset || 0,
        include: [
          {
            model: ServiceTicketMessage,
            as: 'messages',
            where: { isDeleted: false },
            required: false,
            limit: 1,
            order: [['createdAt', 'DESC']]
          }
        ]
      });

      const ticketList = tickets.map(ticket => ({
        id: ticket.id,
        ticketNumber: ticket.ticketNumber,
        ticketType: ticket.ticketType,
        ticketTypeLabel: ServiceTicket.getTicketTypeLabel(ticket.ticketType),
        priority: ticket.priority,
        priorityLabel: ServiceTicket.getPriorityLabel(ticket.priority),
        priorityColor: ticket.getPriorityColor(),
        status: ticket.status,
        statusLabel: ServiceTicket.getStatusLabel(ticket.status),
        statusColor: ticket.getStatusColor(),
        subject: ticket.subject,
        description: ticket.description,
        resolution: ticket.resolution,
        assignedTo: ticket.assignedTo,
        slaHours: ticket.slaHours,
        slaStatus: ticket.getSlaStatus(),
        slaColor: ticket.getSlaColor(),
        timeToSla: ticket.getTimeToSla(),
        isOverdue: ticket.isOverdue(),
        autoGenerated: ticket.autoGenerated,
        generationReason: ticket.generationReason,
        tags: ticket.tags,
        attachments: ticket.attachments,
        createdAt: ticket.createdAt,
        updatedAt: ticket.updatedAt,
        resolvedAt: ticket.resolvedAt,
        closedAt: ticket.closedAt,
        lastActivityAt: ticket.lastActivityAt,
        userResponseCount: ticket.userResponseCount,
        caResponseCount: ticket.caResponseCount,
        escalationCount: ticket.escalationCount,
        lastMessage: ticket.messages && ticket.messages.length > 0 ? ticket.messages[0] : null
      }));

      enterpriseLogger.info('User tickets retrieved', {
        userId,
        count: ticketList.length,
        filters
      });

      return ticketList;

    } catch (error) {
      enterpriseLogger.error('Failed to get user tickets', {
        error: error.message,
        userId,
        filters
      });
      throw error;
    }
  }

  /**
   * Get ticket details with messages
   * @param {string} ticketId - Ticket ID
   * @param {string} userId - User ID
   * @returns {Promise<object>} - Ticket details
   */
  async getTicketDetails(ticketId, userId) {
    try {
      const ticket = await ServiceTicket.findOne({
        where: {
          id: ticketId,
          userId,
          isDeleted: false
        },
        include: [
          {
            model: ServiceTicketMessage,
            as: 'messages',
            where: { isDeleted: false },
            required: false,
            order: [['createdAt', 'ASC']]
          }
        ]
      });

      if (!ticket) {
        throw new AppError('Ticket not found', 404);
      }

      const ticketDetails = {
        id: ticket.id,
        ticketNumber: ticket.ticketNumber,
        ticketType: ticket.ticketType,
        ticketTypeLabel: ServiceTicket.getTicketTypeLabel(ticket.ticketType),
        priority: ticket.priority,
        priorityLabel: ServiceTicket.getPriorityLabel(ticket.priority),
        priorityColor: ticket.getPriorityColor(),
        status: ticket.status,
        statusLabel: ServiceTicket.getStatusLabel(ticket.status),
        statusColor: ticket.getStatusColor(),
        subject: ticket.subject,
        description: ticket.description,
        resolution: ticket.resolution,
        internalNotes: ticket.internalNotes,
        assignedTo: ticket.assignedTo,
        slaHours: ticket.slaHours,
        slaStatus: ticket.getSlaStatus(),
        slaColor: ticket.getSlaColor(),
        timeToSla: ticket.getTimeToSla(),
        isOverdue: ticket.isOverdue(),
        autoGenerated: ticket.autoGenerated,
        generationReason: ticket.generationReason,
        tags: ticket.tags,
        attachments: ticket.attachments,
        metadata: ticket.metadata,
        createdAt: ticket.createdAt,
        updatedAt: ticket.updatedAt,
        resolvedAt: ticket.resolvedAt,
        closedAt: ticket.closedAt,
        firstResponseAt: ticket.firstResponseAt,
        lastActivityAt: ticket.lastActivityAt,
        userResponseCount: ticket.userResponseCount,
        caResponseCount: ticket.caResponseCount,
        escalationCount: ticket.escalationCount,
        messages: ticket.messages.map(message => ({
          id: message.id,
          senderType: message.senderType,
          senderTypeLabel: ServiceTicketMessage.getSenderTypeLabel(message.senderType),
          senderTypeColor: message.getSenderTypeColor(),
          senderTypeIcon: message.getSenderTypeIcon(),
          messageType: message.messageType,
          messageTypeLabel: ServiceTicketMessage.getMessageTypeLabel(message.messageType),
          messageTypeIcon: message.getMessageTypeIcon(),
          message: message.formatMessage(),
          isInternal: message.isInternal,
          attachments: message.attachments,
          metadata: message.metadata,
          createdAt: message.createdAt,
          isFromUser: message.isFromUser(),
          isFromCA: message.isFromCA(),
          isFromAdmin: message.isFromAdmin(),
          isFromSystem: message.isFromSystem(),
          isSystemMessage: message.isSystemMessage(),
          hasAttachments: message.hasAttachments(),
          attachmentCount: message.getAttachmentCount()
        }))
      };

      enterpriseLogger.info('Ticket details retrieved', {
        ticketId,
        userId,
        messageCount: ticket.messages.length
      });

      return ticketDetails;

    } catch (error) {
      enterpriseLogger.error('Failed to get ticket details', {
        error: error.message,
        ticketId,
        userId
      });
      throw error;
    }
  }

  /**
   * Add message to ticket
   * @param {string} ticketId - Ticket ID
   * @param {string} senderId - Sender ID
   * @param {string} message - Message content
   * @param {string} senderType - Sender type
   * @param {Array} attachments - Attachments
   * @returns {Promise<object>} - Created message
   */
  async addMessage(ticketId, senderId, message, senderType = 'USER', attachments = []) {
    try {
      const ticket = await ServiceTicket.findByPk(ticketId);
      if (!ticket) {
        throw new AppError('Ticket not found', 404);
      }

      // Create message
      const ticketMessage = await ServiceTicketMessage.create({
        ticketId,
        senderId,
        senderType,
        message,
        messageType: 'TEXT',
        attachments
      });

      // Update ticket response counts
      if (senderType === 'USER') {
        ticket.userResponseCount += 1;
      } else if (['CA', 'ADMIN'].includes(senderType)) {
        ticket.caResponseCount += 1;
      }

      // Set first response time if this is the first CA/Admin response
      if (['CA', 'ADMIN'].includes(senderType) && !ticket.firstResponseAt) {
        ticket.firstResponseAt = new Date();
      }

      await ticket.save();

      enterpriseLogger.info('Message added to ticket', {
        messageId: ticketMessage.id,
        ticketId,
        senderType,
        messageLength: message.length
      });

      return {
        success: true,
        message: {
          id: ticketMessage.id,
          senderType: ticketMessage.senderType,
          senderTypeLabel: ServiceTicketMessage.getSenderTypeLabel(ticketMessage.senderType),
          senderTypeColor: ticketMessage.getSenderTypeColor(),
          senderTypeIcon: ticketMessage.getSenderTypeIcon(),
          messageType: ticketMessage.messageType,
          messageTypeLabel: ServiceTicketMessage.getMessageTypeLabel(ticketMessage.messageType),
          messageTypeIcon: ticketMessage.getMessageTypeIcon(),
          message: ticketMessage.message,
          isInternal: ticketMessage.isInternal,
          attachments: ticketMessage.attachments,
          createdAt: ticketMessage.createdAt,
          isFromUser: ticketMessage.isFromUser(),
          isFromCA: ticketMessage.isFromCA(),
          isFromAdmin: ticketMessage.isFromAdmin(),
          isFromSystem: ticketMessage.isFromSystem(),
          isSystemMessage: ticketMessage.isSystemMessage(),
          hasAttachments: ticketMessage.hasAttachments(),
          attachmentCount: ticketMessage.getAttachmentCount()
        }
      };

    } catch (error) {
      enterpriseLogger.error('Failed to add message to ticket', {
        error: error.message,
        ticketId,
        senderId,
        senderType
      });
      throw error;
    }
  }

  /**
   * Update ticket status
   * @param {string} ticketId - Ticket ID
   * @param {string} newStatus - New status
   * @param {string} updatedBy - User updating
   * @param {string} resolution - Resolution text
   * @returns {Promise<boolean>} - Success status
   */
  async updateTicketStatus(ticketId, newStatus, updatedBy, resolution = null) {
    try {
      const ticket = await ServiceTicket.findByPk(ticketId);
      if (!ticket) {
        throw new AppError('Ticket not found', 404);
      }

      const oldStatus = ticket.status;
      ticket.status = newStatus;

      if (resolution) {
        ticket.resolution = resolution;
      }

      if (newStatus === 'RESOLVED') {
        ticket.resolvedAt = new Date();
      } else if (newStatus === 'CLOSED') {
        ticket.closedAt = new Date();
      }

      await ticket.save();

      // Create status change message
      await ServiceTicketMessage.createStatusChangeMessage(
        ticketId,
        oldStatus,
        newStatus,
        updatedBy
      );

      enterpriseLogger.info('Ticket status updated', {
        ticketId,
        ticketNumber: ticket.ticketNumber,
        oldStatus,
        newStatus,
        updatedBy
      });

      // Send SSE notification for status update
      sseNotificationService.sendTicketUpdate(ticket.userId, {
        id: ticket.id,
        ticketNumber: ticket.ticketNumber,
        oldStatus,
        newStatus,
        updatedBy,
        resolution
      });

      return true;

    } catch (error) {
      enterpriseLogger.error('Failed to update ticket status', {
        error: error.message,
        ticketId,
        newStatus,
        updatedBy
      });
      throw error;
    }
  }

  /**
   * Assign ticket
   * @param {string} ticketId - Ticket ID
   * @param {string} assignedTo - User to assign to
   * @param {string} assignedBy - User assigning
   * @returns {Promise<boolean>} - Success status
   */
  async assignTicket(ticketId, assignedTo, assignedBy) {
    try {
      const ticket = await ServiceTicket.findByPk(ticketId);
      if (!ticket) {
        throw new AppError('Ticket not found', 404);
      }

      await ticket.assignTo(assignedTo, assignedBy);

      // Create assignment message
      await ServiceTicketMessage.createAssignmentMessage(
        ticketId,
        assignedTo, // This should be the user's name, not ID
        assignedBy
      );

      return true;

    } catch (error) {
      enterpriseLogger.error('Failed to assign ticket', {
        error: error.message,
        ticketId,
        assignedTo,
        assignedBy
      });
      throw error;
    }
  }

  /**
   * Get ticket statistics
   * @param {string} userId - User ID (optional)
   * @returns {Promise<object>} - Statistics
   */
  async getTicketStats(userId = null) {
    try {
      const stats = await ServiceTicket.getTicketStats(userId);

      enterpriseLogger.info('Ticket statistics retrieved', {
        userId,
        stats
      });

      return stats;

    } catch (error) {
      enterpriseLogger.error('Failed to get ticket statistics', {
        error: error.message,
        userId
      });
      throw error;
    }
  }

  /**
   * Validate ticket data
   * @param {object} ticketData - Ticket data
   */
  validateTicketData(ticketData) {
    const { userId, ticketType, subject, description } = ticketData;

    if (!userId) {
      throw new AppError('User ID is required', 400);
    }

    if (!ticketType) {
      throw new AppError('Ticket type is required', 400);
    }

    if (!subject || subject.length === 0) {
      throw new AppError('Subject is required', 400);
    }

    if (!description || description.length === 0) {
      throw new AppError('Description is required', 400);
    }

    const validTicketTypes = [
      'FILING_SUPPORT', 'DOCUMENT_REVIEW', 'TAX_QUERY', 'TECHNICAL_ISSUE',
      'PAYMENT_ISSUE', 'REFUND_REQUEST', 'GENERAL_INQUIRY'
    ];

    if (!validTicketTypes.includes(ticketType)) {
      throw new AppError(`Invalid ticket type: ${ticketType}`, 400);
    }
  }

  /**
   * Get SLA hours for ticket type
   * @param {string} ticketType - Ticket type
   * @returns {number} - SLA hours
   */
  getSlaHoursForType(ticketType) {
    const slaHours = {
      'FILING_SUPPORT': 24,
      'DOCUMENT_REVIEW': 12,
      'TAX_QUERY': 48,
      'TECHNICAL_ISSUE': 6,
      'PAYMENT_ISSUE': 4,
      'REFUND_REQUEST': 72,
      'GENERAL_INQUIRY': 48
    };
    return slaHours[ticketType] || this.defaultSlaHours;
  }

  /**
   * Auto-assign ticket based on type and priority
   * @param {string} ticketType - Ticket type
   * @param {string} priority - Priority
   * @returns {Promise<string|null>} - Assigned user ID
   */
  async autoAssignTicket(ticketType, priority) {
    try {
      // This would typically query for available CAs/Admins
      // For now, return null (no auto-assignment)
      return null;
    } catch (error) {
      enterpriseLogger.error('Failed to auto-assign ticket', {
        error: error.message,
        ticketType,
        priority
      });
      return null;
    }
  }

  /**
   * Get service status
   * @returns {object} - Service status
   */
  getServiceStatus() {
    return {
      autoAssignmentEnabled: this.autoAssignmentEnabled,
      defaultSlaHours: this.defaultSlaHours,
      supportedTicketTypes: [
        'FILING_SUPPORT', 'DOCUMENT_REVIEW', 'TAX_QUERY', 'TECHNICAL_ISSUE',
        'PAYMENT_ISSUE', 'REFUND_REQUEST', 'GENERAL_INQUIRY'
      ],
      supportedPriorities: ['LOW', 'MEDIUM', 'HIGH', 'URGENT', 'CRITICAL'],
      supportedStatuses: [
        'OPEN', 'IN_PROGRESS', 'PENDING_USER', 'PENDING_CA', 
        'RESOLVED', 'CLOSED', 'ESCALATED'
      ]
    };
  }
}

module.exports = new ServiceTicketService();
