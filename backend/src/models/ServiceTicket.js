// =====================================================
// SERVICE TICKET MODEL
// =====================================================

const { DataTypes } = require('sequelize');
const { sequelize } = require('../config/database');
const enterpriseLogger = require('../utils/logger');

const ServiceTicket = sequelize.define('ServiceTicket', {
  id: {
    type: DataTypes.UUID,
    defaultValue: DataTypes.UUIDV4,
    primaryKey: true,
  },
  ticketNumber: {
    type: DataTypes.STRING(20),
    allowNull: false,
    unique: true,
    field: 'ticket_number',
  },
  userId: {
    type: DataTypes.UUID,
    allowNull: false,
    field: 'user_id',
  },
  filingId: {
    type: DataTypes.UUID,
    allowNull: true,
    field: 'filing_id',
  },
  memberId: {
    type: DataTypes.UUID,
    allowNull: true,
    field: 'member_id',
  },
  assignedTo: {
    type: DataTypes.UUID,
    allowNull: true,
    field: 'assigned_to',
  },
  caFirmId: {
    type: DataTypes.UUID,
    allowNull: true,
    field: 'ca_firm_id',
  },
  ticketType: {
    type: DataTypes.ENUM(
      'FILING_SUPPORT',
      'DOCUMENT_REVIEW',
      'TAX_QUERY',
      'TECHNICAL_ISSUE',
      'PAYMENT_ISSUE',
      'REFUND_REQUEST',
      'GENERAL_INQUIRY',
      'CA_REVIEW',
      'EXPERT_REVIEW',
      'RTR_REVIEW',
    ),
    allowNull: false,
    field: 'ticket_type',
  },
  category: {
    type: DataTypes.STRING,
    allowNull: true,
    comment: 'Ticket category for filtering (ca_review, expert_review, rtr_review, etc.)',
  },
  priority: {
    type: DataTypes.ENUM(
      'LOW',
      'MEDIUM',
      'HIGH',
      'URGENT',
      'CRITICAL',
    ),
    allowNull: false,
    defaultValue: 'MEDIUM',
    field: 'priority',
  },
  status: {
    type: DataTypes.ENUM(
      'OPEN',
      'IN_PROGRESS',
      'PENDING_USER',
      'PENDING_CA',
      'RESOLVED',
      'CLOSED',
      'ESCALATED',
    ),
    allowNull: false,
    defaultValue: 'OPEN',
    field: 'status',
  },
  subject: {
    type: DataTypes.STRING(255),
    allowNull: false,
  },
  description: {
    type: DataTypes.TEXT,
    allowNull: false,
  },
  resolution: {
    type: DataTypes.TEXT,
    allowNull: true,
  },
  internalNotes: {
    type: DataTypes.TEXT,
    allowNull: true,
    field: 'internal_notes',
  },
  slaHours: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 24,
    field: 'sla_hours',
  },
  createdAt: {
    type: DataTypes.DATE,
    allowNull: false,
    field: 'created_at',
  },
  updatedAt: {
    type: DataTypes.DATE,
    allowNull: false,
    field: 'updated_at',
  },
  resolvedAt: {
    type: DataTypes.DATE,
    allowNull: true,
    field: 'resolved_at',
  },
  closedAt: {
    type: DataTypes.DATE,
    allowNull: true,
    field: 'closed_at',
  },
  firstResponseAt: {
    type: DataTypes.DATE,
    allowNull: true,
    field: 'first_response_at',
  },
  lastActivityAt: {
    type: DataTypes.DATE,
    allowNull: false,
    defaultValue: DataTypes.NOW,
    field: 'last_activity_at',
  },
  autoGenerated: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: false,
    field: 'auto_generated',
  },
  generationReason: {
    type: DataTypes.STRING(100),
    allowNull: true,
    field: 'generation_reason',
  },
  userResponseCount: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 0,
    field: 'user_response_count',
  },
  caResponseCount: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 0,
    field: 'ca_response_count',
  },
  escalationCount: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 0,
    field: 'escalation_count',
  },
  tags: {
    type: DataTypes.JSONB,
    allowNull: false,
    defaultValue: [],
  },
  attachments: {
    type: DataTypes.JSONB,
    allowNull: false,
    defaultValue: [],
  },
  metadata: {
    type: DataTypes.JSONB,
    allowNull: false,
    defaultValue: {},
  },
  isDeleted: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: false,
    field: 'is_deleted',
  },
  deletedAt: {
    type: DataTypes.DATE,
    allowNull: true,
    field: 'deleted_at',
  },
  deletedBy: {
    type: DataTypes.UUID,
    allowNull: true,
    field: 'deleted_by',
  },
}, {
  tableName: 'service_tickets',
  timestamps: true,
  underscored: true,
  indexes: [
    {
      fields: ['user_id'],
    },
    {
      fields: ['filing_id'],
    },
    {
      fields: ['assigned_to'],
    },
    {
      fields: ['status'],
    },
    {
      fields: ['priority'],
    },
    {
      fields: ['ticket_type'],
    },
    {
      fields: ['created_at'],
    },
    {
      fields: ['ticket_number'],
    },
    {
      fields: ['is_deleted'],
    },
    {
      fields: ['user_id', 'status'],
      where: { is_deleted: false },
    },
    {
      fields: ['assigned_to', 'status'],
      where: { is_deleted: false },
    },
    {
      fields: ['filing_id', 'ticket_type'],
      where: { is_deleted: false },
    },
  ],
});

// Instance methods
ServiceTicket.prototype.getStatusColor = function() {
  const statusColors = {
    'OPEN': 'blue',
    'IN_PROGRESS': 'orange',
    'PENDING_USER': 'yellow',
    'PENDING_CA': 'purple',
    'RESOLVED': 'green',
    'CLOSED': 'gray',
    'ESCALATED': 'red',
  };
  return statusColors[this.status] || 'gray';
};

ServiceTicket.prototype.getPriorityColor = function() {
  const priorityColors = {
    'LOW': 'green',
    'MEDIUM': 'blue',
    'HIGH': 'orange',
    'URGENT': 'red',
    'CRITICAL': 'purple',
  };
  return priorityColors[this.priority] || 'blue';
};

ServiceTicket.prototype.getSlaStatus = function() {
  const now = new Date();
  const created = new Date(this.createdAt);
  const hoursElapsed = (now - created) / (1000 * 60 * 60);
  const slaPercentage = (hoursElapsed / this.slaHours) * 100;

  if (slaPercentage >= 100) {return 'OVERDUE';}
  if (slaPercentage >= 80) {return 'AT_RISK';}
  return 'ON_TRACK';
};

ServiceTicket.prototype.getSlaColor = function() {
  const slaStatus = this.getSlaStatus();
  const slaColors = {
    'ON_TRACK': 'green',
    'AT_RISK': 'orange',
    'OVERDUE': 'red',
  };
  return slaColors[slaStatus] || 'gray';
};

ServiceTicket.prototype.getTimeToSla = function() {
  const now = new Date();
  const created = new Date(this.createdAt);
  const hoursElapsed = (now - created) / (1000 * 60 * 60);
  const hoursRemaining = this.slaHours - hoursElapsed;

  if (hoursRemaining <= 0) {return 'Overdue';}
  if (hoursRemaining < 1) {return `${Math.round(hoursRemaining * 60)} minutes`;}
  if (hoursRemaining < 24) {return `${Math.round(hoursRemaining)} hours`;}
  return `${Math.round(hoursRemaining / 24)} days`;
};

ServiceTicket.prototype.isOverdue = function() {
  return this.getSlaStatus() === 'OVERDUE';
};

ServiceTicket.prototype.canBeResolved = function() {
  return ['OPEN', 'IN_PROGRESS', 'PENDING_USER', 'PENDING_CA'].includes(this.status);
};

ServiceTicket.prototype.canBeClosed = function() {
  return this.status === 'RESOLVED';
};

ServiceTicket.prototype.canBeEscalated = function() {
  return ['OPEN', 'IN_PROGRESS', 'PENDING_USER', 'PENDING_CA'].includes(this.status);
};

ServiceTicket.prototype.markResolved = async function(resolution, resolvedBy) {
  this.status = 'RESOLVED';
  this.resolution = resolution;
  this.resolvedAt = new Date();
  await this.save();

  enterpriseLogger.info('Service ticket marked as resolved', {
    ticketId: this.id,
    ticketNumber: this.ticketNumber,
    resolvedBy,
  });
};

ServiceTicket.prototype.markClosed = async function(closedBy) {
  this.status = 'CLOSED';
  this.closedAt = new Date();
  await this.save();

  enterpriseLogger.info('Service ticket marked as closed', {
    ticketId: this.id,
    ticketNumber: this.ticketNumber,
    closedBy,
  });
};

ServiceTicket.prototype.escalate = async function(escalatedBy, reason) {
  this.status = 'ESCALATED';
  this.escalationCount += 1;
  this.internalNotes = (this.internalNotes || '') + `\nEscalated by ${escalatedBy} at ${new Date().toISOString()}: ${reason}`;
  await this.save();

  enterpriseLogger.info('Service ticket escalated', {
    ticketId: this.id,
    ticketNumber: this.ticketNumber,
    escalatedBy,
    reason,
  });
};

ServiceTicket.prototype.assignTo = async function(assignedTo, assignedBy) {
  this.assignedTo = assignedTo;
  this.internalNotes = (this.internalNotes || '') + `\nAssigned to ${assignedTo} by ${assignedBy} at ${new Date().toISOString()}`;
  await this.save();

  enterpriseLogger.info('Service ticket assigned', {
    ticketId: this.id,
    ticketNumber: this.ticketNumber,
    assignedTo,
    assignedBy,
  });
};

ServiceTicket.prototype.updatePriority = async function(newPriority, updatedBy) {
  const oldPriority = this.priority;
  this.priority = newPriority;
  this.internalNotes = (this.internalNotes || '') + `\nPriority changed from ${oldPriority} to ${newPriority} by ${updatedBy} at ${new Date().toISOString()}`;
  await this.save();

  enterpriseLogger.info('Service ticket priority updated', {
    ticketId: this.id,
    ticketNumber: this.ticketNumber,
    oldPriority,
    newPriority,
    updatedBy,
  });
};

// Class methods
ServiceTicket.getTicketTypeLabel = function(ticketType) {
  const labels = {
    'FILING_SUPPORT': 'Filing Support',
    'DOCUMENT_REVIEW': 'Document Review',
    'TAX_QUERY': 'Tax Query',
    'TECHNICAL_ISSUE': 'Technical Issue',
    'PAYMENT_ISSUE': 'Payment Issue',
    'REFUND_REQUEST': 'Refund Request',
    'GENERAL_INQUIRY': 'General Inquiry',
  };
  return labels[ticketType] || 'Unknown';
};

ServiceTicket.getPriorityLabel = function(priority) {
  const labels = {
    'LOW': 'Low',
    'MEDIUM': 'Medium',
    'HIGH': 'High',
    'URGENT': 'Urgent',
    'CRITICAL': 'Critical',
  };
  return labels[priority] || 'Unknown';
};

ServiceTicket.getStatusLabel = function(status) {
  const labels = {
    'OPEN': 'Open',
    'IN_PROGRESS': 'In Progress',
    'PENDING_USER': 'Pending User',
    'PENDING_CA': 'Pending CA',
    'RESOLVED': 'Resolved',
    'CLOSED': 'Closed',
    'ESCALATED': 'Escalated',
  };
  return labels[status] || 'Unknown';
};

ServiceTicket.generateTicketNumber = async function() {
  const lastTicket = await ServiceTicket.findOne({
    where: {
      ticketNumber: {
        [sequelize.Op.like]: 'TK%',
      },
    },
    order: [['createdAt', 'DESC']],
  });

  let counter = 1;
  if (lastTicket) {
    const lastNumber = lastTicket.ticketNumber.substring(2);
    counter = parseInt(lastNumber) + 1;
  }

  return `TK${counter.toString().padStart(6, '0')}`;
};

ServiceTicket.getTicketStats = async function(userId = null) {
  const whereClause = { isDeleted: false };
  if (userId) {
    whereClause.userId = userId;
  }

  const stats = await ServiceTicket.findAll({
    where: whereClause,
    attributes: [
      [sequelize.fn('COUNT', sequelize.col('id')), 'totalTickets'],
      [sequelize.fn('COUNT', sequelize.literal('CASE WHEN status = \'OPEN\' THEN 1 END')), 'openTickets'],
      [sequelize.fn('COUNT', sequelize.literal('CASE WHEN status = \'IN_PROGRESS\' THEN 1 END')), 'inProgressTickets'],
      [sequelize.fn('COUNT', sequelize.literal('CASE WHEN status = \'RESOLVED\' THEN 1 END')), 'resolvedTickets'],
      [sequelize.fn('COUNT', sequelize.literal('CASE WHEN status = \'CLOSED\' THEN 1 END')), 'closedTickets'],
      [sequelize.fn('COUNT', sequelize.literal('CASE WHEN auto_generated = true THEN 1 END')), 'autoGeneratedTickets'],
      [sequelize.fn('AVG', sequelize.literal('EXTRACT(EPOCH FROM (resolved_at - created_at))/3600')), 'avgResolutionHours'],
    ],
    raw: true,
  });

  return {
    totalTickets: parseInt(stats[0].totalTickets) || 0,
    openTickets: parseInt(stats[0].openTickets) || 0,
    inProgressTickets: parseInt(stats[0].inProgressTickets) || 0,
    resolvedTickets: parseInt(stats[0].resolvedTickets) || 0,
    closedTickets: parseInt(stats[0].closedTickets) || 0,
    autoGeneratedTickets: parseInt(stats[0].autoGeneratedTickets) || 0,
    avgResolutionHours: parseFloat(stats[0].avgResolutionHours) || 0,
  };
};

ServiceTicket.getOverdueTickets = async function() {
  const now = new Date();
  const overdueThreshold = new Date(now.getTime() - (24 * 60 * 60 * 1000)); // 24 hours ago

  return await ServiceTicket.findAll({
    where: {
      isDeleted: false,
      status: {
        [sequelize.Op.in]: ['OPEN', 'IN_PROGRESS', 'PENDING_USER', 'PENDING_CA'],
      },
      createdAt: {
        [sequelize.Op.lt]: overdueThreshold,
      },
    },
    order: [['createdAt', 'ASC']],
  });
};

// Hooks
ServiceTicket.beforeCreate(async (ticket) => {
  if (!ticket.ticketNumber) {
    ticket.ticketNumber = await ServiceTicket.generateTicketNumber();
  }
});

ServiceTicket.afterCreate(async (ticket) => {
  enterpriseLogger.info('Service ticket created', {
    ticketId: ticket.id,
    ticketNumber: ticket.ticketNumber,
    userId: ticket.userId,
    ticketType: ticket.ticketType,
    priority: ticket.priority,
    autoGenerated: ticket.autoGenerated,
  });
});

ServiceTicket.afterUpdate(async (ticket) => {
  if (ticket.changed('status')) {
    enterpriseLogger.info('Service ticket status changed', {
      ticketId: ticket.id,
      ticketNumber: ticket.ticketNumber,
      oldStatus: ticket._previousDataValues.status,
      newStatus: ticket.status,
    });
  }
});

enterpriseLogger.info('ServiceTicket model defined');

module.exports = { ServiceTicket };