Good. Moving on.

---

# ğŸš§ PHASE 3 â€” DB SCHEMA ALIGNMENT (LIGHT, SAFE, IRREVERSIBLE)

**Goal:**
Make your **Supabase schema reflect the Domain Core**, without breaking data, without refactoring, without triggers.

This phase is about **structural integrity**, not features.

---

## What Phase 3 IS and IS NOT

### âœ… IS

* Enforcing lifecycle correctness at persistence level
* Preventing accidental corruption
* Preparing DB for Finance, RBAC, audits

### âŒ IS NOT

* Redesign
* New tables explosion
* Heavy constraints
* Business logic in SQL

---

## PHASE 3 â€” STEPS (STRICT ORDER)

---

## ğŸ”¹ STEP 3.1 â€” Normalize Lifecycle State (MANDATORY)

### Action

For all ITR-related tables (at least):

* `itr_filings`
* `itr_drafts`
* `return_versions`

Ensure a **single canonical column**:

```sql
lifecycle_state ENUM (
  'DRAFT_INIT',
  'ITR_DETERMINED',
  'DATA_COLLECTED',
  'DATA_CONFIRMED',
  'COMPUTED',
  'LOCKED',
  'FILED',
  'ACKNOWLEDGED',
  'COMPLETED'
)
```

Rules:

* Replace free-text `status`
* No branching states
* No UI-specific values

âš ï¸ DB stores state
âŒ DB does NOT decide transitions

---

## ğŸ”¹ STEP 3.2 â€” Enforce Immutability Metadata (NO TRIGGERS)

Add **metadata columns**, not constraints:

```sql
locked_at TIMESTAMP NULL
locked_by UUID NULL
filed_at TIMESTAMP NULL
filed_by UUID NULL
```

Purpose:

* Domain Core uses these as **guards**
* Audits become reliable
* Finance hooks become deterministic

âŒ Do NOT add triggers
âŒ Do NOT block updates in SQL

---

## ğŸ”¹ STEP 3.3 â€” ITR Type Freezing Support

Ensure `itr_type` behaves as:

* Nullable initially
* Must be set once determined
* Must not change after `LOCKED`

DB change:

* NONE mandatory

But:

* Add comment / documentation
* Optional partial index:

```sql
CREATE INDEX idx_itr_locked_type
ON itr_filings (itr_type)
WHERE lifecycle_state IN ('LOCKED','FILED','ACKNOWLEDGED','COMPLETED');
```

This helps audits and finance later.

---

## ğŸ”¹ STEP 3.4 â€” Version & Computation Traceability

Ensure these exist (most already do in your schema):

* `computation_version`
* `computed_at`
* `computed_by`
* `regime_selected`

These should:

* Be immutable after LOCKED
* Be copied into `return_versions`

No triggers â€” Domain Core enforces.

---

## ğŸ”¹ STEP 3.5 â€” Soft Referential Discipline (IMPORTANT)

Verify (do not enforce yet):

* `itr_drafts.filing_id â†’ itr_filings.id`
* `return_versions.filing_id â†’ itr_filings.id`
* Finance tables (future) reference `itr_filings.id`

Just **document** gaps. No migrations yet if risky.

---

## WHAT PHASE 3 DELIVERS

After Phase 3, you get:

* DB mirrors Domain Core states
* Impossible states are eliminated
* Lock/file moments are durable
* Audits become consistent
* Finance module can plug in cleanly
* RBAC scales safely

This is **platform hardening**, not refactor.

---

## âŒ WHAT NOT TO DO IN PHASE 3

Do NOT:

* Add SQL triggers
* Encode business rules in DB
* Change computation fields
* Touch frontend
* Touch RBAC logic
* Touch finance logic

---

## ğŸ“Œ CURSOR INSTRUCTION (COPYâ€“PASTE)

Give Cursor exactly this:

> **â€œProceed with Phase 3 DB alignment: normalize lifecycle_state enum, add lock/file metadata fields, support itr_type freezing, improve version traceability. Do NOT add triggers or business logic in SQL. No UI or service refactors.â€**

---

## NEXT PHASE (PREVIEW)

Once Phase 3 is done:

### ğŸ”¥ Phase 4 â€” UI Simplification

* Kill step-based logic
* UI driven entirely by `allowed_actions`
* Massive reduction in frontend complexity

### ğŸ’° Phase 5 â€” Finance Module

* Billing
* Invoicing
* Payments
* Refunds

Say **â€œPhase 3 completeâ€** when done, and weâ€™ll move to Phase 4.
