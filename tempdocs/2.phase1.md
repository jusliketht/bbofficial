Excellent. This is **exactly where a real platform turns from â€œworkingâ€ to â€œcorrectâ€**.

You now have something very rare:

* A **formal domain**
* A **complete mapping**
* A **measured risk report**
* Zero guesswork

Iâ€™ll proceed **decisively and surgically**.
No theory. No rewrites. No churn.

---

# NEXT SURGICAL STEP â€” PHASE 1

## Make the Domain Core **AUTHORITATIVE** (Not Yet Everywhere)

### Objective

Turn the Domain Core from a **placeholder** into a **gatekeeper**, without breaking the app.

This phase:

* DOES NOT refactor all code
* DOES NOT touch UI deeply
* DOES NOT change DB
* DOES NOT block shipping

It only **prevents new violations** and **stabilizes behavior**.

---

## STEP 1 â€” Lock the Domain Core Contract (MANDATORY)

### Action

In `backend/src/domain/ITRDomainCore.js`:

Implement **only these methods first**:

```ts
determineITR(signals)
getAllowedActions(state, actor)
canTransition(fromState, toState)
shouldRecompute(prevSnapshot, newSnapshot)
```

â— DO NOT add:

* DB access
* API calls
* Side effects

This file must be:

> **Pure logic + rules only**

This becomes the **single source of truth**.

---

## STEP 2 â€” Add a Domain Guard Middleware (CRITICAL)

### Create

```
backend/src/middleware/domainGuard.js
```

### Responsibility

Before **any** of these actions:

* Draft update
* Income mutation
* ITR switch
* Compute
* Lock
* File

The middleware must:

1. Ask Domain Core:

   * current state
   * intended action
2. If âŒ â†’ reject
3. If âœ… â†’ allow

This alone will eliminate **80% of unsafe logic immediately**.

ğŸ’¡ You do NOT need to refactor controllers yet â€” just guard them.

---

## STEP 3 â€” Enforce LOCKED State (NON-NEGOTIABLE)

From your findings:

> 20% of files mutate data after LOCKED

Fix this **globally**:

### Rule

If `state === LOCKED`:

* No mutation routes are allowed
* No service writes allowed
* No CA overrides allowed

Implementation:

* One check in Domain Guard
* One check in write services (defensive)

This is the **single most important integrity rule**.

---

## STEP 4 â€” Centralize ITR Switching (HIGH IMPACT, LOW EFFORT)

From mapping:

> 8+ ITR switching violations

### Fix

* Remove ITR switching logic from:

  * Controllers
  * Services
  * Frontend
* Route all switches through:

```ts
DomainCore.determineITR()
```

If ITR changes:

* Auto-rollback to `ITR_DETERMINED`
* Invalidate computation
* Emit notice

This immediately stabilizes ITR 1â€“4 correctness.

---

## STEP 5 â€” Do NOT Touch These Yet (IMPORTANT)

Do **NOT** refactor yet:

* TaxComputationEngine
* ValidationEngine
* Frontend flows
* Supabase schema
* Finance logic

They will naturally fall in line **after Phase 1**.

---

# PHASE 1 OUTPUT (What â€œDONEâ€ looks like)

When Phase 1 is complete, you should be able to say:

* âœ… No data mutation after LOCKED
* âœ… No ITR switch outside Domain Core
* âœ… Controllers no longer decide legality
* âœ… Domain Core blocks invalid actions
* âœ… App still works

This is **platform stabilization**, not cleanup.

---

# WHAT COMES NEXT (ALREADY DECIDED)

After Phase 1, we proceed in this exact order:

### Phase 2 â€” Move Logic INTO Domain Core

* Gradually pull:

  * ITR determination
  * Recompute triggers
  * Validation gating
* Reduce duplication

### Phase 3 â€” DB Alignment (Light Touch)

* State enum
* Immutability metadata
* Indexing

### Phase 4 â€” UI Simplification

* UI becomes reactive to `allowed_actions`
* Massive complexity reduction

### Phase 5 â€” Finance Module Plug-in

* Billing
* Invoicing
* Refunds
* Payments

---

## One instruction for you now



> **â€œImplement Domain Guard + enforce LOCKED invariants using ITRDomainCore without refactoring controllers.â€**

When Phase 1 is done, come back and say:

> **â€œPhase 1 complete.â€**

Then we move to Phase 2 â€” where BurnBlack becomes hard to beat.
